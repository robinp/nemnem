<html><head><title>NemNem</title><link rel="stylesheet" type="text/css" href="static/nemnem.css"><script src="static/jquery-2.0.3.min.js"></script><script src="static/nemnem.js"></script></head><body><div id="code"><span class="mpre">{-# LANGUAGE CPP #-}
</span><span class="hl_comment"><span class="mpre">{- |
Module      :  Control.Monad.Error
Copyright   :  (c) Michael Weber &lt;michael.weber@post.rwth-aachen.de&gt; 2001,
               (c) Jeff Newbern 2003-2006,
               (c) Andriy Palamarchuk 2006
License     :  BSD-style (see the file LICENSE)

Maintainer  :  libraries@haskell.org
Stability   :  experimental
Portability :  non-portable (multi-parameter type classes)

[Computation type:] Computations which may fail or throw exceptions.

[Binding strategy:] Failure records information about the cause\/location
of the failure. Failure values bypass the bound function,
other values are used as inputs to the bound function.

[Useful for:] Building computations from sequences of functions that may fail
or using exception handling to structure error handling.

[Example type:] @&#39;Data.Either&#39; String a@

The Error monad (also called the Exception monad).
-}</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">{-
  Rendered by Michael Weber &lt;mailto:michael.weber@post.rwth-aachen.de&gt;,
  inspired by the Haskell Monad Template Library from
    Andy Gill (&lt;http://web.cecs.pdx.edu/~andy/&gt;)
-}</span></span><span class="mpre">
module Control.Monad.Except
  (
    </span><span class="hl_comment"><span class="mpre">-- * Monads with error handling</span></span><span class="mpre">
    MonadError(..),
    </span><span class="hl_comment"><span class="mpre">-- * The ErrorT monad transformer</span></span><span class="mpre">
    ExceptT(ExceptT),
    Except,

    runExceptT,
    mapExceptT,
    withExceptT,
    runExcept,
    mapExcept,
    withExcept,

    module Control.Monad,
    module Control.Monad.Fix,
    module Control.Monad.Trans,
    </span><span class="hl_comment"><span class="mpre">-- * Example 1: Custom Error Data Type</span></span><span class="mpre">
    </span><span class="hl_comment"><span class="mpre">-- $customErrorExample</span></span><span class="mpre">

    </span><span class="hl_comment"><span class="mpre">-- * Example 2: Using ExceptT Monad Transformer</span></span><span class="mpre">
    </span><span class="hl_comment"><span class="mpre">-- $ExceptTExample</span></span><span class="mpre">
  ) where

import Control.Monad.Error.Class
import Control.Monad.Trans
import Control.Monad.Trans.Except
  ( </span><a href="Control.Monad.Trans.Except.html#loc_98_9_98_16" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_98_9_98_16&#39;)"><span class="mpre">ExceptT</span></a><span class="mpre">(</span><a href="Control.Monad.Trans.Except.html#loc_98_25_98_32" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_98_25_98_32&#39;)"><span class="mpre">ExceptT</span></a><span class="mpre">), Except, </span><a href="Control.Monad.Trans.Except.html#loc_67_1_67_7" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_67_1_67_7&#39;)"><span class="mpre">except</span></a><span class="mpre">
  , </span><a href="Control.Monad.Trans.Except.html#loc_72_1_72_10" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_72_1_72_10&#39;)"><span class="mpre">runExcept</span></a><span class="mpre">, </span><a href="Control.Monad.Trans.Except.html#loc_119_1_119_11" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_119_1_119_11&#39;)"><span class="mpre">runExceptT</span></a><span class="mpre">
  , </span><a href="Control.Monad.Trans.Except.html#loc_80_1_80_10" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_80_1_80_10&#39;)"><span class="mpre">mapExcept</span></a><span class="mpre">, </span><a href="Control.Monad.Trans.Except.html#loc_127_1_127_11" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_127_1_127_11&#39;)"><span class="mpre">mapExceptT</span></a><span class="mpre">
  , </span><a href="Control.Monad.Trans.Except.html#loc_85_1_85_11" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_85_1_85_11&#39;)"><span class="mpre">withExcept</span></a><span class="mpre">, </span><a href="Control.Monad.Trans.Except.html#loc_132_1_132_12" onmouseover="nemnem.highlightLocalToRemote(&#39;Control.Monad.Trans.Except.html#loc_132_1_132_12&#39;)"><span class="mpre">withExceptT</span></a><span class="mpre">
  )

import Control.Monad
import Control.Monad.Fix

#if defined(__GLASGOW_HASKELL__) &amp;&amp; __GLASGOW_HASKELL__ &lt; 707
import Control.Monad.Instances ()
#endif

</span><span class="hl_comment"><span class="mpre">{- $customErrorExample
Here is an example that demonstrates the use of a custom error data type with
the &#39;throwError&#39; and &#39;catchError&#39; exception mechanism from &#39;MonadError&#39;.
The example throws an exception if the user enters an empty string
or a string longer than 5 characters. Otherwise it prints length of the string.

&gt;-- This is the type to represent length calculation error.
&gt;data LengthError = EmptyString  -- Entered string was empty.
&gt;          | StringTooLong Int   -- A string is longer than 5 characters.
&gt;                                -- Records a length of the string.
&gt;          | OtherError String   -- Other error, stores the problem description.
&gt;
&gt;-- Converts LengthError to a readable message.
&gt;instance Show LengthError where
&gt;  show EmptyString = &quot;The string was empty!&quot;
&gt;  show (StringTooLong len) =
&gt;      &quot;The length of the string (&quot; ++ (show len) ++ &quot;) is bigger than 5!&quot;
&gt;  show (OtherError msg) = msg
&gt;
&gt;-- For our monad type constructor, we use Either LengthError
&gt;-- which represents failure using Left LengthError
&gt;-- or a successful result of type a using Right a.
&gt;type LengthMonad = Either LengthError
&gt;
&gt;main = do
&gt;  putStrLn &quot;Please enter a string:&quot;
&gt;  s &lt;- getLine
&gt;  reportResult (calculateLength s)
&gt;
&gt;-- Wraps length calculation to catch the errors.
&gt;-- Returns either length of the string or an error.
&gt;calculateLength :: String -&gt; LengthMonad Int
&gt;calculateLength s = (calculateLengthOrFail s) `catchError` Left
&gt;
&gt;-- Attempts to calculate length and throws an error if the provided string is
&gt;-- empty or longer than 5 characters.
&gt;-- The processing is done in Either monad.
&gt;calculateLengthOrFail :: String -&gt; LengthMonad Int
&gt;calculateLengthOrFail [] = throwError EmptyString
&gt;calculateLengthOrFail s | len &gt; 5 = throwError (StringTooLong len)
&gt;                        | otherwise = return len
&gt;  where len = length s
&gt;
&gt;-- Prints result of the string length calculation.
&gt;reportResult :: LengthMonad Int -&gt; IO ()
&gt;reportResult (Right len) = putStrLn (&quot;The length of the string is &quot; ++ (show len))
&gt;reportResult (Left e) = putStrLn (&quot;Length calculation failed with error: &quot; ++ (show e))
-}</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">{- $ExceptTExample
@&#39;ExceptT&#39;@ monad transformer can be used to add error handling to another monad.
Here is an example how to combine it with an @IO@ monad:

&gt;import Control.Monad.Except
&gt;
&gt;-- An IO monad which can return String failure.
&gt;-- It is convenient to define the monad type of the combined monad,
&gt;-- especially if we combine more monad transformers.
&gt;type LengthMonad = ExceptT String IO
&gt;
&gt;main = do
&gt;  -- runExceptT removes the ExceptT wrapper
&gt;  r &lt;- runExceptT calculateLength
&gt;  reportResult r
&gt;
&gt;-- Asks user for a non-empty string and returns its length.
&gt;-- Throws an error if user enters an empty string.
&gt;calculateLength :: LengthMonad Int
&gt;calculateLength = do
&gt;  -- all the IO operations have to be lifted to the IO monad in the monad stack
&gt;  liftIO $ putStrLn &quot;Please enter a non-empty string: &quot;
&gt;  s &lt;- liftIO getLine
&gt;  if null s
&gt;    then throwError &quot;The string was empty!&quot;
&gt;    else return $ length s
&gt;
&gt;-- Prints result of the string length calculation.
&gt;reportResult :: Either String Int -&gt; IO ()
&gt;reportResult (Right len) = putStrLn (&quot;The length of the string is &quot; ++ (show len))
&gt;reportResult (Left e) = putStrLn (&quot;Length calculation failed with error: &quot; ++ (show e))
-}</span></span><span class="mpre">
</span></div></body></html>