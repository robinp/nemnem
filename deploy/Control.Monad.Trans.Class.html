<html><head><title>NemNem</title><link rel="stylesheet" type="text/css" href="static/nemnem.css"><script src="static/jquery-2.0.3.min.js"></script><script src="static/nemnem.js"></script></head><body><div id="code"><span class="hl_comment"><span class="mpre">-----------------------------------------------------------------------------</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- |</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Module      :  Control.Monad.Trans.Class</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Copyright   :  (c) Andy Gill 2001,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--                (c) Oregon Graduate Institute of Science and Technology, 2001</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- License     :  BSD-style (see the file LICENSE)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Maintainer  :  ross@soi.city.ac.uk</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Stability   :  experimental</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Portability :  portable</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Classes for monad transformers.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- A monad transformer makes a new monad out of an existing monad, such</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- that computations of the old monad may be embedded in the new one.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- To construct a monad with a desired set of features, one typically</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- starts with a base monad, such as @Identity@, @[]@ or &#39;IO&#39;, and</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- applies a sequence of monad transformers.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Most monad transformer modules include the special case of applying the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- transformer to @Identity@.  For example, @State s@ is an abbreviation</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- for @StateT s Identity@.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Each monad transformer also comes with an operation @run@/XXX/ to</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- unwrap the transformer, exposing a computation of the inner monad.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-----------------------------------------------------------------------------</span></span><span class="mpre">

module Control.Monad.Trans.Class (
    </span><span class="hl_comment"><span class="mpre">-- * Transformer class</span></span><span class="mpre">
    MonadTrans(..)

    </span><span class="hl_comment"><span class="mpre">-- * Examples</span></span><span class="mpre">
    </span><span class="hl_comment"><span class="mpre">-- ** Parsing</span></span><span class="mpre">
    </span><span class="hl_comment"><span class="mpre">-- $example1</span></span><span class="mpre">

    </span><span class="hl_comment"><span class="mpre">-- ** Parsing and counting</span></span><span class="mpre">
    </span><span class="hl_comment"><span class="mpre">-- $example2</span></span><span class="mpre">
  ) where

</span><span class="hl_comment"><span class="mpre">-- | The class of monad transformers.  Instances should satisfy the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- following laws, which state that &#39;lift&#39; is a transformer of monads:</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- * @&#39;lift&#39; . &#39;return&#39; = &#39;return&#39;@</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- * @&#39;lift&#39; (m &gt;&gt;= f) = &#39;lift&#39; m &gt;&gt;= (&#39;lift&#39; . f)@</span></span><span class="mpre">

class </span><a name="loc_47_7_47_17" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_47_7_47_17&#39;)"><span class="hl_classdecl"><span class="mpre">MonadTrans</span></span></a><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">t</span></span><span class="mpre"> where
    </span><span class="hl_comment"><span class="mpre">-- | Lift a computation from the argument monad to the constructed monad.</span></span><span class="mpre">
    </span><a name="loc_49_5_49_9" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_49_5_49_9&#39;)"><span class="mpre">lift</span></a><span class="mpre"> :: </span><span class="warning" data-warning="ContextCxSingle (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/transformers-0.3.0.0/Control/Monad/Trans/Class.hs&quot;, srcSpanStartLine = 49, srcSpanStartColumn = 13, srcSpanEndLine = 49, srcSpanEndColumn = 23}, srcInfoPoints = [SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/transformers-0.3.0.0/Control/Monad/Trans/Class.hs&quot;, srcSpanStartLine = 49, srcSpanStartColumn = 21, srcSpanEndLine = 49, srcSpanEndColumn = 23}]}) (ClassA (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagran"><span class="mpre">Monad m =&gt;</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">m</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">a</span></span><span class="mpre"> -&gt; </span><span class="hl_tyvar"><span class="mpre">t</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">m</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">a</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">{- $example1

One might define a parsing monad by adding a state (the &#39;String&#39; remaining
to be parsed) to the @[]@ monad, which provides non-determinism:

&gt; import Control.Monad.Trans.State
&gt;
&gt; type Parser = StateT String []

Then @Parser@ is an instance of @MonadPlus@: monadic sequencing implements
concatenation of parsers, while @mplus@ provides choice.
To use parsers, we need a primitive to run a constructed parser on an
input string:

&gt; runParser :: Parser a -&gt; String -&gt; [a]
&gt; runParser p s = [x | (x, &quot;&quot;) &lt;- runStateT p s]

Finally, we need a primitive parser that matches a single character,
from which arbitrarily complex parsers may be constructed:

&gt; item :: Parser Char
&gt; item = do
&gt;     c:cs &lt;- get
&gt;     put cs
&gt;     return c

In this example we use the operations @get@ and @put@ from
&quot;Control.Monad.Trans.State&quot;, which are defined only for monads that are
applications of @StateT@.  Alternatively one could use monad classes
from the @mtl@ package or similar, which contain methods @get@ and @put@
with types generalized over all suitable monads.
-}</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">{- $example2

We can define a parser that also counts by adding a @WriterT@ transformer:

&gt; import Control.Monad.Trans.Class
&gt; import Control.Monad.Trans.State
&gt; import Control.Monad.Trans.Writer
&gt; import Data.Monoid
&gt;
&gt; type Parser = WriterT (Sum Int) (StateT String [])

The function that applies a parser must now unwrap each of the monad
transformers in turn:

&gt; runParser :: Parser a -&gt; String -&gt; [(a, Int)]
&gt; runParser p s = [(x, n) | ((x, Sum n), &quot;&quot;) &lt;- runStateT (runWriterT p) s]

To define @item@ parser, we need to lift the @StateT@ operations through
the @WriterT@ transformers.

&gt; item :: Parser Char
&gt; item = do
&gt;     c:cs &lt;- lift get
&gt;     lift (put cs)
&gt;     return c

In this case, we were able to do this with &#39;lift&#39;, but operations with
more complex types require special lifting functions, which are provided
by monad transformers for which they can be implemented.  If you use the
monad classes of the @mtl@ package or similar, this lifting is handled
automatically by the instances of the classes, and you need only use
the generalized methods @get@ and @put@.

We can also define a primitive using the Writer:

&gt; tick :: Parser ()
&gt; tick = tell (Sum 1)

Then the parser will keep track of how many @tick@s it executes.
-}</span></span><span class="mpre">
</span></div></body></html>