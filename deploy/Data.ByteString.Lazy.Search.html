<html><head><title>NemNem</title><link rel="stylesheet" type="text/css" href="static/nemnem.css"><script src="static/jquery-2.0.3.min.js"></script><script src="static/nemnem.js"></script></head><body><div id="code"><span class="hl_comment"><span class="mpre">-- |</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Module         : Data.ByteString.Lazy.Search</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Copyright      : Daniel Fischer</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--                  Chris Kuklewicz</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Licence        : BSD3</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Maintainer     : Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Stability      : Provisional</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Portability    : non-portable (BangPatterns)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Fast overlapping Boyer-Moore search of lazy</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- &#39;L.ByteString&#39; values. Breaking, splitting and replacing</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- using the Boyer-Moore algorithm.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Descriptions of the algorithm can be found at</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- &lt;http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140&gt;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- and</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- &lt;http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm&gt;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Original authors: Daniel Fischer (daniel.is.fischer at googlemail.com) and</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Chris Kuklewicz (haskell at list.mightyreason.com).</span></span><span class="mpre">
module Data.ByteString.Lazy.Search( </span><span class="hl_comment"><span class="mpre">-- * Overview</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $overview</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- ** Performance</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $performance</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- ** Caution</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $caution</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- ** Complexity</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $complexity</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- ** Partial application</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $partial</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- ** Integer overflow</span></span><span class="mpre">
                                    </span><span class="hl_comment"><span class="mpre">-- $overflow</span></span><span class="mpre">

                                    </span><span class="hl_comment"><span class="mpre">-- * Finding substrings</span></span><span class="mpre">
                                    indices
                                  , nonOverlappingIndices
                                    </span><span class="hl_comment"><span class="mpre">-- * Breaking on substrings</span></span><span class="mpre">
                                  , breakOn
                                  , breakAfter
                                  , breakFindAfter
                                    </span><span class="hl_comment"><span class="mpre">-- * Replacing</span></span><span class="mpre">
                                  , replace
                                    </span><span class="hl_comment"><span class="mpre">-- * Splitting</span></span><span class="mpre">
                                  , split
                                  , splitKeepEnd
                                  , splitKeepFront
                                    </span><span class="hl_comment"><span class="mpre">-- * Convenience</span></span><span class="mpre">
                                  , strictify
                                  ) where

import qualified Data.ByteString.Lazy.Search.Internal.BoyerMoore as BM
import Data.ByteString.Search.Substitution
import qualified </span><span class="warning" data-warning="Module not foundModuleName (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/stringsearch-0.3.6.5/Data/ByteString/Lazy/Search.hs&quot;, srcSpanStartLine = 58, srcSpanStartColumn = 18, srcSpanEndLine = 58, srcSpanEndColumn = 33}, srcInfoPoints = []}) &quot;Data.ByteString&quot;"><span class="mpre">Data.ByteString</span></span><span class="mpre"> as S
import qualified </span><span class="warning" data-warning="Module not foundModuleName (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/stringsearch-0.3.6.5/Data/ByteString/Lazy/Search.hs&quot;, srcSpanStartLine = 59, srcSpanStartColumn = 18, srcSpanEndLine = 59, srcSpanEndColumn = 38}, srcInfoPoints = []}) &quot;Data.ByteString.Lazy&quot;"><span class="mpre">Data.ByteString.Lazy</span></span><span class="mpre"> as L

import Data.Int (</span><a href="GHC.Int.html#loc_551_30_551_35" onmouseover="nemnem.highlightLocalToRemote(&#39;GHC.Int.html#loc_551_30_551_35&#39;)"><span class="mpre">Int64</span></a><span class="mpre">)

</span><span class="hl_comment"><span class="mpre">-- $overview</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- This module provides functions related to searching a substring within</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- a string, using the Boyer-Moore algorithm with minor modifications</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- to improve the overall performance and ameliorate the worst case</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- performance degradation of the original Boyer-Moore algorithm for</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- periodic patterns.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Efficiency demands that the pattern be a strict &#39;S.ByteString&#39;,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- to work with a lazy pattern, convert it to a strict &#39;S.ByteString&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- first via &#39;strictify&#39; (provided it is not too long).</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- If support for long lazy patterns is needed, mail a feature-request.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- When searching a pattern in a UTF-8-encoded &#39;S.ByteString&#39;, be aware that</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- these functions work on bytes, not characters, so the indices are</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- byte-offsets, not character offsets.</span></span><span class="mpre">


</span><span class="hl_comment"><span class="mpre">-- $performance</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- In general, the Boyer-Moore algorithm is the most efficient method to</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- search for a pattern inside a string. The advantage over other algorithms</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- (e.g. Na&amp;#239;ve, Knuth-Morris-Pratt, Horspool, Sunday) can be made</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- arbitrarily large for specially selected patterns and targets, but</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- usually, it&#39;s a factor of 2&amp;#8211;3 versus Knuth-Morris-Pratt and of</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- 6&amp;#8211;10 versus the na&amp;#239;ve algorithm. The Horspool and Sunday</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- algorithms, which are simplified variants of the Boyer-Moore algorithm,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- typically have performance between Boyer-Moore and Knuth-Morris-Pratt,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- mostly closer to Boyer-Moore. The advantage of the Boyer-moore variants</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- over other algorithms generally becomes larger for longer patterns. For</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- very short patterns (or patterns with a very short period), other</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- algorithms, e.g. &quot;Data.ByteString.Lazy.Search.DFA&quot; can be faster (my</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- tests suggest that \&quot;very short\&quot; means two, maybe three bytes).</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- In general, searching in a strict &#39;S.ByteString&#39; is slightly faster</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- than searching in a lazy &#39;L.ByteString&#39;, but for long targets the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- smaller memory footprint of lazy &#39;L.ByteString&#39;s can make searching</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- those (sometimes much) faster. On the other hand, there are cases</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- where searching in a strict target is much faster, even for long targets.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- On 32-bit systems, &#39;Int&#39;-arithmetic is much faster than &#39;Int64&#39;-arithmetic,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- so when there are many matches, that can make a significant difference.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Also, the modification to ameliorate the case of periodic patterns</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- is defeated by chunk-boundaries, so long patterns with a short period</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- and many matches exhibit poor behaviour (consider using @indices@ from</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- &quot;Data.ByteString.Lazy.Search.DFA&quot; or &quot;Data.ByteString.Lazy.Search.KMP&quot;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- in those cases, the former for medium-length patterns, the latter for</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- long patterns; none of the functions except &#39;indices&#39; suffer from</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- this problem, though).</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- $caution</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- When working with a lazy target string, the relation between the pattern</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- length and the chunk size can play a big r&amp;#244;le.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Crossing chunk boundaries is relatively expensive, so when that becomes</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- a frequent occurrence, as may happen when the pattern length is close</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- to or larger than the chunk size, performance is likely to degrade.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- If it is needed, steps can be taken to ameliorate that effect, but unless</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- entirely separate functions are introduced, that would hurt the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- performance for the more common case of patterns much shorter than</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- the default chunk size.</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- $complexity</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Preprocessing the pattern is /O/(@patternLength@ + &amp;#963;) in time and</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- space (&amp;#963; is the alphabet size, 256 here) for all functions.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- The time complexity of the searching phase for &#39;indices&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- is /O/(@targetLength@ \/ @patternLength@) in the best case.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- For non-periodic patterns, the worst case complexity is</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- /O/(@targetLength@), but for periodic patterns, the worst case complexity</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- is /O/(@targetLength@ * @patternLength@) for the original Boyer-Moore</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- algorithm.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- The searching functions in this module contain a modification which</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- drastically improves the performance for periodic patterns, although</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- less for lazy targets than for strict ones.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- If I&#39;m not mistaken, the worst case complexity for periodic patterns</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- is /O/(@targetLength@ * (1 + @patternLength@ \/ @chunkSize@)).</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- The other functions don&#39;t have to deal with possible overlapping</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- patterns, hence the worst case complexity for the processing phase</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- is /O/(@targetLength@) (respectively /O/(@firstIndex + patternLength@)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- for the breaking functions if the pattern occurs).</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- $partial</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- All functions can usefully be partially applied. Given only a pattern,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- the pattern is preprocessed only once, allowing efficient re-use.</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- $overflow</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- The current code uses @Int@ to keep track of the locations in the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- target string.  If the length of the pattern plus the length of any</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- strict chunk of the target string is greater or equal to</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @&#39;maxBound&#39; :: &#39;Int&#39;@ then this will overflow causing an error.  We try</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- to detect this and call &#39;error&#39; before a segfault occurs.</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">------------------------------------------------------------------------------</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--                            Exported Functions                            --</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">------------------------------------------------------------------------------</span></span><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;indices&#39;@ finds the starting indices of all possibly overlapping</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   occurrences of the pattern in the target string.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   If the pattern is empty, the result is @[0 .. &#39;length&#39; target]@.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_172_1_172_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_172_1_172_8&#39;)"><span class="mpre">indices</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_172_1_172_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_172_1_172_8&#39;)"><span class="mpre">indices</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">     </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to find</span></span><span class="mpre">
        -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">     </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to search</span></span><span class="mpre">
        -&gt; [</span><a href="GHC.Int.html#loc_551_30_551_35" onmouseover="nemnem.highlightLocalToRemote(&#39;GHC.Int.html#loc_551_30_551_35&#39;)"><span class="hl_tyconref"><span class="mpre">Int64</span></span></a><span class="mpre">]          </span><span class="hl_comment"><span class="mpre">-- ^ Offsets of matches</span></span><span class="mpre">
</span><a name="loc_172_1_172_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_172_1_172_8&#39;)"><span class="hl_vardecl"><span class="mpre">indices</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_206_1_206_8" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_206_1_206_8&#39;)"><span class="hl_varref"><span class="mpre">BM.matchSL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;nonOverlappingIndices&#39;@ finds the starting indices of all</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   non-overlapping occurrences of the pattern in the target string.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   It is more efficient than removing indices from the list produced</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   by &#39;indices&#39;.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_182_1_182_22" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_182_1_182_22&#39;)"><span class="mpre">nonOverlappingIndices</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_182_1_182_22" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_182_1_182_22&#39;)"><span class="mpre">nonOverlappingIndices</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">   </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to find</span></span><span class="mpre">
                      -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">   </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to search</span></span><span class="mpre">
                      -&gt; [</span><a href="GHC.Int.html#loc_551_30_551_35" onmouseover="nemnem.highlightLocalToRemote(&#39;GHC.Int.html#loc_551_30_551_35&#39;)"><span class="hl_tyconref"><span class="mpre">Int64</span></span></a><span class="mpre">]        </span><span class="hl_comment"><span class="mpre">-- ^ Offsets of matches</span></span><span class="mpre">
</span><a name="loc_182_1_182_22" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_182_1_182_22&#39;)"><span class="hl_vardecl"><span class="mpre">nonOverlappingIndices</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_216_1_216_9" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_216_1_216_9&#39;)"><span class="hl_varref"><span class="mpre">BM.matchNOL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;breakOn&#39; pattern target@ splits @target@ at the first occurrence</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   of @pattern@. If the pattern does not occur in the target, the</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   second component of the result is empty, otherwise it starts with</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   @pattern@. If the pattern is empty, the first component is empty.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   For a non-empty pattern, the first component is generated lazily,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   thus the first parts of it can be available before the pattern has</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   been found or determined to be absent.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;uncurry&#39; &#39;L.append&#39; . &#39;breakOn&#39; pattern = &#39;id&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_200_1_200_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_200_1_200_8&#39;)"><span class="mpre">breakOn</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_200_1_200_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_200_1_200_8&#39;)"><span class="mpre">breakOn</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to search for</span></span><span class="mpre">
        -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to search in</span></span><span class="mpre">
        -&gt; (</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">, </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">)
                         </span><span class="hl_comment"><span class="mpre">-- ^ Head and tail of string broken at substring</span></span><span class="mpre">
</span><a name="loc_200_1_200_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_200_1_200_8&#39;)"><span class="hl_vardecl"><span class="mpre">breakOn</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_287_1_287_16" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_287_1_287_16&#39;)"><span class="hl_varref"><span class="mpre">BM.breakSubstringL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;breakAfter&#39; pattern target@ splits @target@ behind the first occurrence</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   of @pattern@. An empty second component means that either the pattern</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   does not occur in the target or the first occurrence of pattern is at</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   the very end of target. If you need to discriminate between those cases,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   use breakFindAfter.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   If the pattern is empty, the first component is empty.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   For a non-empty pattern, the first component is generated lazily,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   thus the first parts of it can be available before the pattern has</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   been found or determined to be absent.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;uncurry&#39; &#39;L.append&#39; . &#39;breakAfter&#39; pattern = &#39;id&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_220_1_220_11" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_220_1_220_11&#39;)"><span class="mpre">breakAfter</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_220_1_220_11" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_220_1_220_11&#39;)"><span class="mpre">breakAfter</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to search for</span></span><span class="mpre">
           -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to search in</span></span><span class="mpre">
           -&gt; (</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">, </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">)
                            </span><span class="hl_comment"><span class="mpre">-- ^ Head and tail of string broken after substring</span></span><span class="mpre">
</span><a name="loc_220_1_220_11" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_220_1_220_11&#39;)"><span class="hl_vardecl"><span class="mpre">breakAfter</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_296_1_296_12" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_296_1_296_12&#39;)"><span class="hl_varref"><span class="mpre">BM.breakAfterL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;breakFindAfter&#39;@ does the same as &#39;breakAfter&#39; but additionally indicates</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   whether the pattern is present in the target.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;fst&#39; . &#39;breakFindAfter&#39; pat = &#39;breakAfter&#39; pat</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_234_1_234_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_234_1_234_15&#39;)"><span class="mpre">breakFindAfter</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_234_1_234_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_234_1_234_15&#39;)"><span class="mpre">breakFindAfter</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to search for</span></span><span class="mpre">
               -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">  </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to search in</span></span><span class="mpre">
               -&gt; ((</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">, </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">), </span><span class="hl_tyconref"><span class="mpre">Bool</span></span><span class="mpre">)
                            </span><span class="hl_comment"><span class="mpre">-- ^ Head and tail of string broken after substring</span></span><span class="mpre">
                            </span><span class="hl_comment"><span class="mpre">--   and presence of pattern</span></span><span class="mpre">
</span><a name="loc_234_1_234_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_234_1_234_15&#39;)"><span class="hl_vardecl"><span class="mpre">breakFindAfter</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_310_1_310_16" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_310_1_310_16&#39;)"><span class="hl_varref"><span class="mpre">BM.breakFindAfterL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;replace&#39; pat sub text@ replaces all (non-overlapping) occurrences of</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   @pat@ in @text@ with @sub@. If occurrences of @pat@ overlap, the first</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   occurrence that does not overlap with a replaced previous occurrence</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   is substituted. Occurrences of @pat@ arising from a substitution</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   will not be substituted. For example:</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;replace&#39; \&quot;ana\&quot; \&quot;olog\&quot; \&quot;banana\&quot; = \&quot;bologna\&quot;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;replace&#39; \&quot;ana\&quot; \&quot;o\&quot; \&quot;bananana\&quot; = \&quot;bono\&quot;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;replace&#39; \&quot;aab\&quot; \&quot;abaa\&quot; \&quot;aaabb\&quot; = \&quot;aabaab\&quot;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   The result is a lazy &#39;L.ByteString&#39;,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   which is lazily produced, without copying.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   Equality of pattern and substitution is not checked, but</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;replace&#39; pat pat text == text</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   holds (the internal structure is generally different).</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   If the pattern is empty but not the substitution, the result</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   is equivalent to (were they &#39;String&#39;s) @cycle sub@.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   For non-empty @pat@ and @sub@ a lazy &#39;L.ByteString&#39;,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;L.concat&#39; . &#39;Data.List.intersperse&#39; sub . &#39;split&#39; pat = &#39;replace&#39; pat sub</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   and analogous relations hold for other types of @sub@.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_273_1_273_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_273_1_273_8&#39;)"><span class="mpre">replace</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_273_1_273_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_273_1_273_8&#39;)"><span class="mpre">replace</span></a><span class="mpre"> :: </span><span class="warning" data-warning="ContextCxSingle (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/stringsearch-0.3.6.5/Data/ByteString/Lazy/Search.hs&quot;, srcSpanStartLine = 268, srcSpanStartColumn = 12, srcSpanEndLine = 269, srcSpanEndColumn = 11}, srcInfoPoints = [SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/stringsearch-0.3.6.5/Data/ByteString/Lazy/Search.hs&quot;, srcSpanStartLine = 269, srcSpanStartColumn = 9, srcSpanEndLine = 269, srcSpanEndColumn = 11}]}) (ClassA (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home"><span class="mpre">Substitution rep
        =&gt;</span></span><span class="mpre"> </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">     </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to replace</span></span><span class="mpre">
        -&gt; </span><span class="hl_tyvar"><span class="mpre">rep</span></span><span class="mpre">              </span><span class="hl_comment"><span class="mpre">-- ^ Replacement string</span></span><span class="mpre">
        -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">     </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to modify</span></span><span class="mpre">
        -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">     </span><span class="hl_comment"><span class="mpre">-- ^ Lazy result</span></span><span class="mpre">
</span><a name="loc_273_1_273_8" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_273_1_273_8&#39;)"><span class="hl_vardecl"><span class="mpre">replace</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_247_1_247_12" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_247_1_247_12&#39;)"><span class="hl_varref"><span class="mpre">BM.replaceAllL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;split&#39; pattern target@ splits @target@ at each (non-overlapping)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   occurrence of @pattern@, removing @pattern@. If @pattern@ is empty,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   the result is an infinite list of empty &#39;L.ByteString&#39;s, if @target@</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   is empty but not @pattern@, the result is an empty list, otherwise</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   the following relations hold (where @patL@ is the lazy &#39;L.ByteString&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   corresponding to @pat@):</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;L.concat&#39; . &#39;Data.List.intersperse&#39; patL . &#39;split&#39; pat = &#39;id&#39;,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;length&#39; (&#39;split&#39; pattern target) ==</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--               &#39;length&#39; (&#39;nonOverlappingIndices&#39; pattern target) + 1,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   no fragment in the result contains an occurrence of @pattern@.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_293_1_293_6" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_293_1_293_6&#39;)"><span class="mpre">split</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_293_1_293_6" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_293_1_293_6&#39;)"><span class="mpre">split</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">   </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to split on</span></span><span class="mpre">
      -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">   </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to split</span></span><span class="mpre">
      -&gt; [</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">] </span><span class="hl_comment"><span class="mpre">-- ^ Fragments of string</span></span><span class="mpre">
</span><a name="loc_293_1_293_6" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_293_1_293_6&#39;)"><span class="hl_vardecl"><span class="mpre">split</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_376_1_376_11" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_376_1_376_11&#39;)"><span class="hl_varref"><span class="mpre">BM.splitDropL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;splitKeepEnd&#39; pattern target@ splits @target@ after each (non-overlapping)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   occurrence of @pattern@. If @pattern@ is empty, the result is an</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   infinite list of empty &#39;L.ByteString&#39;s, otherwise the following</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   relations hold:</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   &#39;L.concat&#39; . &#39;splitKeepEnd&#39; pattern = &#39;id&#39;,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- @</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   all fragments in the result except possibly the last end with</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   @pattern@, no fragment contains more than one occurrence of @pattern@.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_310_1_310_13" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_310_1_310_13&#39;)"><span class="mpre">splitKeepEnd</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_310_1_310_13" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_310_1_310_13&#39;)"><span class="mpre">splitKeepEnd</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">    </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to split on</span></span><span class="mpre">
             -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">    </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to split</span></span><span class="mpre">
             -&gt; [</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">]  </span><span class="hl_comment"><span class="mpre">-- ^ Fragments of string</span></span><span class="mpre">
</span><a name="loc_310_1_310_13" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_310_1_310_13&#39;)"><span class="hl_vardecl"><span class="mpre">splitKeepEnd</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_355_1_355_14" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_355_1_355_14&#39;)"><span class="hl_varref"><span class="mpre">BM.splitKeepEndL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;splitKeepFront&#39;@ is like &#39;splitKeepEnd&#39;, except that @target@ is split</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   before each occurrence of @pattern@ and hence all fragments</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   with the possible exception of the first begin with @pattern@.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   No fragment contains more than one non-overlapping occurrence</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   of @pattern@.</span></span><span class="mpre">
</span><span class="hl_pragma"><span class="mpre">{-# INLINE </span><a href="#loc_321_1_321_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_321_1_321_15&#39;)"><span class="mpre">splitKeepFront</span></a><span class="mpre"> #-}</span></span><span class="mpre">
</span><a href="#loc_321_1_321_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_321_1_321_15&#39;)"><span class="mpre">splitKeepFront</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">    </span><span class="hl_comment"><span class="mpre">-- ^ Strict pattern to split on</span></span><span class="mpre">
               -&gt; </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">    </span><span class="hl_comment"><span class="mpre">-- ^ Lazy string to split</span></span><span class="mpre">
               -&gt; [</span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre">]  </span><span class="hl_comment"><span class="mpre">-- ^ Fragments of string</span></span><span class="mpre">
</span><a name="loc_321_1_321_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_321_1_321_15&#39;)"><span class="hl_vardecl"><span class="mpre">splitKeepFront</span></span></a><span class="mpre"> = </span><a href="Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_365_1_365_16" onmouseover="nemnem.highlightLocalToRemote(&#39;Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#loc_365_1_365_16&#39;)"><span class="hl_varref"><span class="mpre">BM.splitKeepFrontL</span></span></a><span class="mpre">

</span><span class="hl_comment"><span class="mpre">-- | @&#39;strictify&#39;@ converts a lazy &#39;L.ByteString&#39; to a strict &#39;S.ByteString&#39;</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--   to make it a suitable pattern.</span></span><span class="mpre">
</span><a href="#loc_326_1_326_10" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_326_1_326_10&#39;)"><span class="mpre">strictify</span></a><span class="mpre"> :: </span><span class="hl_tyconref"><span class="mpre">L.ByteString</span></span><span class="mpre"> -&gt; </span><span class="hl_tyconref"><span class="mpre">S.ByteString</span></span><span class="mpre">
</span><a name="loc_326_1_326_10" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_326_1_326_10&#39;)"><span class="hl_vardecl"><span class="mpre">strictify</span></span></a><span class="mpre"> = </span><span class="hl_varref"><span class="mpre">S.concat</span></span><span class="mpre"> </span><span class="hl_infix"><span class="mpre">.</span></span><span class="mpre"> </span><span class="hl_varref"><span class="mpre">L.toChunks</span></span><span class="mpre">
</span></div></body></html>