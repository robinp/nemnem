<html><head><title>NemNem</title><link rel="stylesheet" type="text/css" href="/static/nemnem.css"><script src="/static/jquery-2.0.3.min.js"></script><script src="/static/nemnem.js"></script></head><body><div id="code"><span class="mpre">{-# LANGUAGE RankNTypes #-}
</span><span class="hl_comment"><span class="mpre">-----------------------------------------------------------------------------</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- |</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Module      :  Data.Array.ST</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Copyright   :  (c) The University of Glasgow 2001</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Maintainer  :  libraries@haskell.org</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Stability   :  experimental</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Portability :  non-portable (uses Data.Array.MArray)</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Mutable boxed and unboxed arrays in the &#39;Control.Monad.ST.ST&#39; monad.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-----------------------------------------------------------------------------</span></span><span class="mpre">

module Data.Array.ST (
   </span><span class="hl_comment"><span class="mpre">-- * Boxed arrays</span></span><span class="mpre">
   STArray,             </span><span class="hl_comment"><span class="mpre">-- instance of: Eq, MArray</span></span><span class="mpre">
   runSTArray,

   </span><span class="hl_comment"><span class="mpre">-- * Unboxed arrays</span></span><span class="mpre">
   STUArray,            </span><span class="hl_comment"><span class="mpre">-- instance of: Eq, MArray</span></span><span class="mpre">
   runSTUArray,

   </span><span class="hl_comment"><span class="mpre">-- * Overloaded mutable array interface</span></span><span class="mpre">
   module Data.Array.MArray,
 ) where

import </span><span class="warning" data-warning="Module not foundModuleName (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 29, srcSpanStartColumn = 8, srcSpanEndLine = 29, srcSpanEndColumn = 23}, srcInfoPoints = []}) &quot;Data.Array.Base&quot;"><span class="mpre">Data.Array.Base</span></span><span class="mpre">  ( STUArray, UArray, unsafeFreezeSTUArray )
import Data.Array.MArray
import Control.Monad.ST ( ST, runST )

import </span><span class="warning" data-warning="Module not foundModuleName (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 33, srcSpanStartColumn = 8, srcSpanEndLine = 33, srcSpanEndColumn = 15}, srcInfoPoints = []}) &quot;GHC.Arr&quot;"><span class="mpre">GHC.Arr</span></span><span class="mpre">          ( STArray, Array, unsafeFreezeSTArray )

</span><span class="hl_comment"><span class="mpre">-- | A safe way to create and work with a mutable array before returning an</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- immutable array for later perusal.  This function avoids copying</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- the array before returning it - it uses &#39;unsafeFreeze&#39; internally, but</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- this wrapper is a safe interface to that function.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><a href="#loc_43_1_43_11" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_43_1_43_11&#39;)"><span class="mpre">runSTArray</span></a><span class="mpre"> :: </span><span class="warning" data-warning="ContextCxParen (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 40, srcSpanStartColumn = 15, srcSpanEndLine = 41, srcSpanEndColumn = 14}, srcInfoPoints = [SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 40, srcSpanStartColumn = 15, srcSpanEndLine = 40, srcSpanEndColumn = 16},SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 40, srcSpanS"><span class="mpre">(Ix i)
           =&gt;</span></span><span class="mpre"> (forall </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> . </span><span class="hl_tyconref"><span class="mpre">ST</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> (</span><span class="hl_tyconref"><span class="mpre">STArray</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">i</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">e</span></span><span class="mpre">))
           -&gt; </span><span class="hl_tyconref"><span class="mpre">Array</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">i</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">e</span></span><span class="mpre">
</span><a name="loc_43_1_43_11" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_43_1_43_11&#39;)"><span class="hl_fundecl"><span class="mpre">runSTArray</span></span></a><span class="mpre"> </span><a name="loc_43_12_43_14" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_43_12_43_14&#39;)"><span class="hl_vardecl"><span class="mpre">st</span></span></a><span class="mpre"> = </span><span class="hl_varref"><span class="mpre">runST</span></span><span class="mpre"> (</span><a href="#loc_43_12_43_14" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_43_12_43_14&#39;)"><span class="hl_varref"><span class="mpre">st</span></span></a><span class="mpre"> </span><span class="hl_infix"><span class="mpre">&gt;&gt;=</span></span><span class="mpre"> </span><span class="hl_varref"><span class="mpre">unsafeFreezeSTArray</span></span><span class="mpre">)

</span><span class="hl_comment"><span class="mpre">-- | A safe way to create and work with an unboxed mutable array before</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- returning an immutable array for later perusal.  This function</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- avoids copying the array before returning it - it uses</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- &#39;unsafeFreeze&#39; internally, but this wrapper is a safe interface to</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- that function.</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><a href="#loc_54_1_54_12" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_54_1_54_12&#39;)"><span class="mpre">runSTUArray</span></a><span class="mpre"> :: </span><span class="warning" data-warning="ContextCxParen (SrcSpanInfo {srcInfoSpan = SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 51, srcSpanStartColumn = 16, srcSpanEndLine = 52, srcSpanEndColumn = 14}, srcInfoPoints = [SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 51, srcSpanStartColumn = 16, srcSpanEndLine = 51, srcSpanEndColumn = 17},SrcSpan {srcSpanFilename = &quot;/home/vagrant/nemnem/pull/array-0.5.0.0/Data/Array/ST.hs&quot;, srcSpanStartLine = 51, srcSpanS"><span class="mpre">(Ix i)
           =&gt;</span></span><span class="mpre"> (forall </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> . </span><span class="hl_tyconref"><span class="mpre">ST</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> (</span><span class="hl_tyconref"><span class="mpre">STUArray</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">s</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">i</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">e</span></span><span class="mpre">))
           -&gt; </span><span class="hl_tyconref"><span class="mpre">UArray</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">i</span></span><span class="mpre"> </span><span class="hl_tyvar"><span class="mpre">e</span></span><span class="mpre">
</span><a name="loc_54_1_54_12" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_54_1_54_12&#39;)"><span class="hl_fundecl"><span class="mpre">runSTUArray</span></span></a><span class="mpre"> </span><a name="loc_54_13_54_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_54_13_54_15&#39;)"><span class="hl_vardecl"><span class="mpre">st</span></span></a><span class="mpre"> = </span><span class="hl_varref"><span class="mpre">runST</span></span><span class="mpre"> (</span><a href="#loc_54_13_54_15" onmouseover="nemnem.highlightLocalToLocal(&#39;loc_54_13_54_15&#39;)"><span class="hl_varref"><span class="mpre">st</span></span></a><span class="mpre"> </span><span class="hl_infix"><span class="mpre">&gt;&gt;=</span></span><span class="mpre"> </span><span class="hl_varref"><span class="mpre">unsafeFreezeSTUArray</span></span><span class="mpre">)


</span><span class="hl_comment"><span class="mpre">-- INTERESTING... this is the type we&#39;d like to give to runSTUArray:</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- runSTUArray :: (Ix i, IArray UArray e,</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--              forall s. MArray (STUArray s) e (ST s))</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--         =&gt; (forall s . ST s (STUArray s i e))</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--         -&gt; UArray i e</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">--</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- Note the quantified constraint.  We dodged the problem by using</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- unsafeFreezeSTUArray directly in the defn of runSTUArray above, but</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- this essentially constrains us to a single unsafeFreeze for all STUArrays</span></span><span class="mpre">
</span><span class="hl_comment"><span class="mpre">-- (in theory we might have a different one for certain element types).</span></span><span class="mpre">
</span></div></body></html>